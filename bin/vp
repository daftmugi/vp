#!/usr/bin/env ruby

################################################################################
# VP.rb                                                                        #
################################################################################
#
# VP Packer/Unpacker for FreeSpace.
# https://github.com/daftmugi/vp

################################################################################
# VP Package Spec                                                              #
################################################################################
#
# VP Package
#     Header
#     Entry Data
#     Table
#
# Header
#     char id[4]         // "VPVP"
#     int version        // 2
#     int table_offset   // Offset to the entries table
#     int num_entries    // Number of entries
#
# Entry
#     int offset         // Offset of the entry
#     int size           // Size of the data
#     char name[32]      // Null-terminated filename
#     int timestamp      // Last modified (mtime) as unix time
#
# Entry Type
#     if name == ".." then @end-of-directory
#     else-if size == 0 then @directory
#     else @file
#
# * Entry Data are stored consecutively without spaces or null-termination.
# * Valid VP packages begin with a "data" directory.
# * VP packages can have empty directories (e.g. sparky_hi_fs2.vp "data/fonts/").
# * VP packages cannot have empty files.
# * Retail VP packages have directories with timestamps of 0.
# * Timestamps are not used in identifying directories.
# * The VP Table does not need to end with ".." (@end-of-directory) entries.

################################################################################
# MIT License                                                                  #
################################################################################
#
# Copyright (c) 2022 Daft Mugi
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

if Gem::Version.new(RUBY_VERSION) < Gem::Version.new("3.0.0")
  abort("Ruby 3.0+ is required")
end

require "fileutils"

class VP
  VERSION = "1.0.4"

  MAX_VP_SIZE = 2**32-1 # 32-bit unsigned int
  MAX_ENTRIES = 2**32-1 # 32-bit unsigned int

  # 4-byte null-padded ASCII string, three 32-bit unsigned little-endian integers
  HEADER_TEMPLATE = "a4V3"
  # id(char[4]) + version(4) + table_offset(4) + num_entries(4)
  HEADER_SIZE_BYTES = 16
  HEADER_ID = "VPVP"
  HEADER_VERSION = 2

  # two ints, 32-byte null-padded ASCII string, one int
  ENTRY_TEMPLATE = "V2a32V1"
  # offset(4) + size(4) + name(char[32]) + timestamp(4)
  ENTRY_SIZE_BYTES = 44
  ENTRY_NAME_LENGTH = 32

  Header = Struct.new(:table_offset, :num_entries, keyword_init: true)

  Entry = Struct.new(:name, :path, :is_dir, :offset, :size, :timestamp) do
    def initialize(name:, path:, is_dir:, offset: 0, size: 0, timestamp: 0)
      super(name, path, is_dir, offset, size, timestamp)
    end

    def skip?
      size == 0 && !is_dir
    end
  end

  attr_reader :options

  def self.main(args = ARGV)
    debug_mode = args.include?("--debug")
    self.new.run(args)
  rescue => e
    raise e if debug_mode
    abort(e.message)
  end

  def initialize(opts = nil)
    @options = default_options()
    set_options(opts) if opts
  end

  def default_options
    {
      command: nil,
      regex: nil,
      ignore_vps: [],
      vp_path: nil,
      root_path: nil,

      to_lower: false,
      noop: false,
      verbose: false,
      very_verbose: false,
    }
  end

  def set_options(opts)
    @options.merge!(opts)
  end

  def to_lower?
    @options[:to_lower]
  end

  def noop?
    @options[:noop]
  end

  def verbose?
    @options[:verbose] || @options[:very_verbose]
  end

  def very_verbose?
    @options[:very_verbose]
  end

  def run(args)
    # For "list" piped to "less", handle "Broken pipe <STDOUT> (Errno::EPIPE)"
    Signal.trap("SIGPIPE", "SYSTEM_DEFAULT")

    # For "Ctrl-c" at prompts
    Signal.trap("SIGINT", "SYSTEM_DEFAULT")

    set_options(process_args(args))

    case options[:command]
    when :list             then list_vp()
    when :extract          then extract_vp()
    when :pipe_extract     then pipe_extract_vp()
    when :create           then create_vp()
    when :find_duplicates  then find_duplicates()
    else raise(usage)
    end
  end

  def usage
    cmd = File.basename($0)

    <<~EOS
    #{cmd} version #{VERSION}

    Usage: #{cmd} -l VP_FILE [REGEX]        [-L]      [-v | -vv]
           #{cmd} -x VP_FILE [REGEX] -d DIR [-L] [-n]
           #{cmd} -p VP_FILE [REGEX]        [-L]
           #{cmd} -c VP_FILE         -d DIR [-L] [-n] [-v | -vv]
           #{cmd} -D [EXCLUDE_VPS]

    Commands:
        -l VP_FILE    : list VP package files
        -x VP_FILE    : extract VP package
        -p VP_FILE    : extract VP package files to stdout (pipe)
        -c VP_FILE    : create VP package
        -D            : read VP packages and print duplicates
        -D help       : print more details about -D usage
        --help, -h    : print this message
        --version     : print version

    Options:
        REGEX         : filter files by a regular expression
        EXCLUDE_VPS   : comma-separated VP set 'a,b,...' to exclude
        -d DIR        : create from/extract to directory
        -L            : convert filenames to lowercase
        -n            : no-op, dry-run
        -v            : verbose
        -vv           : verbose with extra info (very verbose)
        --debug       : print more detailed error messages
    EOS
  end

  def ignore_vps_usage
    cmd = File.basename($0)

    <<~EOS
    Usage: #{cmd} -D [EXCLUDE_VPS]

    -D
        Finds duplicate file paths in VP packages of the current directory.
        This is useful for finding conflicting files.

    EXCLUDE_VPS
        Comma-separated set of VPs to exclude, in the form 'a,b,...'.
        The VPs in the set do not need to include the '.vp' extension.

        A duplicate file prints only if there is at least one VP not
        included in the EXCLUDE_VPS set.

        Examples:
          vp0.vp -> data/a.txt
          vp1.vp -> data/a.txt
          vp1.vp -> data/b.txt
          vp2.vp -> data/b.txt
          vp2.vp -> data/c.txt
          vp3.vp -> data/c.txt

          $ #{cmd} -D
          data/a.txt: vp0.vp, vp1.vp
          data/b.txt: vp1.vp, vp2.vp
          data/c.txt: vp2.vp, vp3.vp

          $ #{cmd} -D vp0
          data/a.txt: vp0.vp, vp1.vp
          data/b.txt: vp1.vp, vp2.vp
          data/c.txt: vp2.vp, vp3.vp

          $ #{cmd} -D vp0,vp1
          data/b.txt: vp1.vp, vp2.vp
          data/c.txt: vp2.vp, vp3.vp

          $ #{cmd} -D vp1,vp2
          data/a.txt: vp0.vp, vp1.vp
          data/c.txt: vp2.vp, vp3.vp

          $ #{cmd} -D vp0,vp1,vp2
          data/c.txt: vp2.vp, vp3.vp

          $ #{cmd} -D vp0,vp1,vp2,vp3
          <no output>
    EOS
  end

  def process_args(args)
    opts = {}

    if args.size < 1
      raise(usage)
    end

    if args.include?("-h") || args.include?("--help")
      puts(usage)
      exit(0)
    end

    if args.include?("--version")
      puts(VERSION)
      exit(0)
    end

    if args.include?("-L")
      opts[:to_lower] = true
    end

    if args.include?("-n")
      opts[:noop] = true
    end

    if args.include?("-v")
      opts[:verbose] = true
    end

    if args.include?("-vv")
      opts[:very_verbose] = true
    end

    if index = args.find_index("-l")
      raise(usage) if opts[:command]
      opts[:command] = :list
      raise(usage) unless opts[:vp_path] = args[index + 1]
      opts[:regex] = maybe_regex(args[index + 2])
    end

    if index = args.find_index("-x")
      raise(usage) if opts[:command]
      opts[:command] = :extract
      raise(usage) unless opts[:vp_path] = args[index + 1]
      opts[:regex] = maybe_regex(args[index + 2])
    end

    if index = args.find_index("-p")
      raise(usage) if opts[:command]
      opts[:command] = :pipe_extract
      raise(usage) unless opts[:vp_path] = args[index + 1]
      opts[:regex] = maybe_regex(args[index + 2])
    end

    if index = args.find_index("-c")
      raise(usage) if opts[:command]
      opts[:command] = :create
      raise(usage) unless opts[:vp_path] = args[index + 1]
    end

    if index = args.find_index("-D")
      raise(usage) if opts[:command]
      opts[:command] = :find_duplicates
      if args[index + 1] == "help"
        puts(ignore_vps_usage)
        exit(0)
      end
      opts[:ignore_vps] = maybe_ignore_vps(args[index + 1])
    end

    if index = args.find_index("-d")
      raise(usage) unless opts[:root_path] = args[index + 1]
    end

    opts
  end

  def maybe_regex(arg)
    return nil if !arg || arg.start_with?("-")
    Regexp.new(arg)
  end

  def maybe_ignore_vps(arg)
    return [] if !arg || arg.start_with?("-")
    arg.split(",").map { |vp| vp.end_with?(".vp") ? vp : "#{vp}.vp" }
  end

  def validate_options
    raise("No command given") unless options[:command]
    raise("No VP file given") unless options[:vp_path]

    root_path = options[:root_path]
    if root_path
      case options[:command]
      when :list
        raise("Cannot use '-d' with list")
      when :pipe_extract
        raise("Cannot use '-d' with pipe")
      end
    else
      case options[:command]
      when :extract
        raise("Must use '-d' to specify the directory to extract the VP to")
      when :create
        raise("Must use '-d' to specify the directory to create the VP from")
      end
    end
  end


  ######################################################################
  # READ VP
  ######################################################################

  def open_vp(vp_path, &block)
    vp_path_expanded = File.expand_path(vp_path)

    raise("File not found: #{vp_path}") unless File.exist?(vp_path)
    raise("Not a file: #{vp_path}")     unless File.file?(vp_path)

    File.open(vp_path_expanded, "rb") do |vp_file|
      id = vp_file.read(4) # "VPVP"
      raise("Not a VP package: #{vp_path}") if id != HEADER_ID
      version = read_int(vp_file)
      raise("Invalid VP version: #{version}") if version != HEADER_VERSION
      yield(vp_file)
    end
  end

  def each_vp_entry(vp_file, &block)
    header = read_header(vp_file)
    table = extract_table(header, vp_file)

    table.each do |entry|
      yield(entry)
    end
  end

  def read_header(vp_file)
    vp_file.seek(8) # id(4) + version(4)
    table_offset = read_int(vp_file)
    num_entries = read_int(vp_file)
    Header.new(table_offset: table_offset, num_entries: num_entries)
  end

  def read_filename(file)
    # null-terminated string
    file.read(ENTRY_NAME_LENGTH).unpack("Z#{ENTRY_NAME_LENGTH}")[0]
  end

  def read_int(file)
    # 32-bit unsigned little
    file.read(4).unpack("V")[0]
  end

  def extract_table(header, vp_file)
    vp_file.seek(header.table_offset)

    table = []
    dir_path = []

    (0...header.num_entries).each do |i|
      offset = read_int(vp_file)
      size = read_int(vp_file)
      filename = read_filename(vp_file)
      filename = filename.downcase if to_lower?
      timestamp = read_int(vp_file)

      if filename == ".."
        raise("Directory not size 0: ..") unless size == 0
        dir_path.pop()
        next
      end

      path =
        if size == 0 # dir
          dir_path << filename
          File.join(dir_path)
        else # file
          File.join(dir_path, filename)
        end

      next if options[:regex] && !path.match?(options[:regex])

      entry = Entry.new(
        name: filename,
        path: path,
        is_dir: size == 0,
        offset: offset,
        size: size,
        timestamp: timestamp
      )

      table << entry
    end

    table
  end


  ######################################################################
  # LIST
  ######################################################################

  def list_vp
    set_options(command: :list)
    validate_options()

    open_vp(options[:vp_path]) do |vp_file|
      print_list_header()

      total_size = 0
      total_files = 0

      each_vp_entry(vp_file) do |entry|
        total_size += entry.size
        total_files += 1
        print_list_entry(entry, total_size, total_files)
      end

      print_list_footer(total_size, total_files)
    end
  end

  def print_list_entry(entry, total_size, total_files)
    entry_path = format_path(entry.path, entry.is_dir)

    if verbose?
      entry_data = [format_size(entry.size)]
      entry_data << entry.offset if very_verbose?
      entry_data << format_timestamp(entry.timestamp)
      entry_data << entry_path

      fmt_str = very_verbose? ? "%10s  %10s  %20s  %s" : "%10s  %20s  %s"
      puts(fmt_str % entry_data)
    else
      puts(entry_path)
    end
  end

  def print_list_header
    return unless verbose?
    puts("Archive: #{options[:vp_path]}")

    if very_verbose?
      puts("   Size       Offset       Date       Time    Path")
      puts("----------  ----------  ----------  --------  -----------------------------------")
    else
      puts("   Size        Date       Time    Path")
      puts("----------  ----------  --------  -----------------------------------")
    end
  end

  def print_list_footer(total_size, total_files)
    return unless verbose?
    files_string = total_files == 1 ? "file" : "files"

    if very_verbose?
      puts("----------                                    -----------------------------------")
      puts("%10d                                    %d %s" % [total_size, total_files, files_string])
    else
      puts("----------                        -----------------------------------")
      puts("%10d                        %d %s" % [total_size, total_files, files_string])
    end
  end


  ######################################################################
  # PIPE EXTRACT
  ######################################################################

  def pipe_extract_vp
    set_options(command: :pipe_extract)
    validate_options()

    open_vp(options[:vp_path]) do |vp_file|
      each_vp_entry(vp_file) do |entry|
        next if entry.is_dir
        pipe_entry(entry, vp_file)
      end
    end
  end

  def pipe_entry(entry, vp_file)
    stream_entry(entry, vp_file, $stdout)
  end


  ######################################################################
  # EXTRACT
  ######################################################################

  def extract_vp
    set_options(command: :extract)
    validate_options()

    root_path = options[:root_path]
    raise("Invalid target directory: ''") if root_path.empty?
    raise("File exists: #{root_path}")    if File.file?(root_path)

    open_vp(options[:vp_path]) do |vp_file|
      entry_fmt_str = "%10s    %s"
      handle_conflict_choice = :not_set

      each_vp_entry(vp_file) do |entry|
        write_path = File.join(root_path, entry.path)
        parent_path = File.dirname(write_path)
        file_in_path = get_closest_file_in_path(parent_path)

        # NOTE
        #   Warn that directory from archive cannot overwrite file on disk.
        #   Warn that file from archive cannot overwrite directory on disk.
        status =
          if entry.is_dir
            if File.directory?(write_path)
              strings(:skip)
            elsif File.file?(write_path)
              :dir_is_file
            elsif file_in_path
              :dir_path_has_file
            else
              mkdir_p(write_path)
              strings(:create)
            end
          else # file
            if File.directory?(write_path)
              :file_is_dir
            elsif File.file?(write_path)
              handle_conflict_choice = handle_conflict(entry.path, handle_conflict_choice)
              case handle_conflict_choice
              when :yes, :all
                write_entry(entry, vp_file, write_path)
                strings(:overwrite)
              else
                strings(:skip)
              end
            elsif file_in_path
              :file_path_has_file
            else
              mkdir_p(parent_path)
              write_entry(entry, vp_file, write_path)
              strings(:extract)
            end
          end

        case status
        when :file_is_dir, :dir_is_file, :dir_path_has_file, :file_path_has_file
          error_message_1 =
            case status
            when :file_is_dir
              "%s exists but is not a file" % [format_path(write_path, true)]
            when :dir_is_file
              "%s exists but is not a directory" % [write_path]
            else
              "%s exists but is not a directory" % [file_in_path]
            end
          puts(entry_fmt_str % ["error", error_message_1])
          error_message_2 = "-> skipping %s" % [format_path(entry.path, entry.is_dir)]
          puts(entry_fmt_str % ["", error_message_2])
        else
          puts(entry_fmt_str % [status, format_path(entry.path, entry.is_dir)])
        end
      end
    end
  end

  def get_closest_file_in_path(path)
    return nil   if File.directory?(path)
    return path  if File.file?(path)

    parent = File.dirname(path)
    get_closest_file_in_path(parent)
  end

  def write_entry(entry, vp_file, file_path)
    return if noop?
    File.open(file_path, "wb") do |file|
      stream_entry(entry, vp_file, file)
    end
    File.utime(entry.timestamp, entry.timestamp, file_path)
  end

  def handle_conflict(path, previous_conflict_choice)
    choice = :invalid
    conflict_choice =
      case previous_conflict_choice
      when :all, :none
        previous_conflict_choice
      else
        choice = prompt_user_about_conflict(path) while choice == :invalid
        choice
      end

    conflict_choice
  end

  def prompt_user_about_conflict(path)
    $stderr.print("replace? #{path} [y]es, [n]o, [A]ll, [N]one: ")
    choice = $stdin.readline().strip()

    case choice
    when "y" then :yes
    when "n" then :no
    when "A" then :all
    when "N" then :none
    else :invalid
    end
  end


  ######################################################################
  # CREATE
  ######################################################################

  def create_vp
    set_options(command: :create)
    validate_options()

    vp_path = options[:vp_path]
    vp_path_expanded = File.expand_path(options[:vp_path])
    root_path = options[:root_path]

    raise("Invalid source directory: ''")              if root_path.empty?
    raise("File already exists: #{vp_path}")           if File.exist?(vp_path)
    raise("Not a directory: #{root_path}")             if File.file?(root_path)
    raise("Directory not found: #{root_path}")     unless File.directory?(root_path)
    raise("Source directory must be named 'data'") unless File.basename(root_path) == "data"

    dirname = File.dirname(options[:root_path])
    Dir.chdir(dirname) do
      file_list = data_file_list()
      validate_file_list(file_list)

      new_vp_file(vp_path_expanded) do |vp_file|
        entries = archive_files(file_list, vp_file)
        table_offset = archive_table(entries, vp_file)
        header = Header.new(table_offset: table_offset, num_entries: entries.size)
        archive_header(header, vp_file)
      end
    end
  end

  def new_vp_file(path, &block)
    if noop?
      require "stringio"
      StringIO.open("", "wb", &block)
    else
      File.open(path, "wb", &block)
    end
  end

  def archive_header(header, vp_file)
    vp_file.seek(0)
    header_data = [
      HEADER_ID,
      HEADER_VERSION,
      header.table_offset,
      header.num_entries
    ]
    packed_header = header_data.pack(HEADER_TEMPLATE)
    vp_write(packed_header, vp_file)
  end

  def archive_table(entries, vp_file)
    table_offset = vp_file.tell()

    entries.each do |entry|
      entry_name = to_lower? ? entry.name.downcase() : entry.name

      entry_data = [
        entry.offset,
        entry.size,
        entry_name.encode("ascii"),
        entry.timestamp,
      ]
      packed_entry = entry_data.pack(ENTRY_TEMPLATE)
      vp_write(packed_entry, vp_file)
    end

    table_offset
  end

  def archive_files(file_list, vp_file)
    vp_file.seek(HEADER_SIZE_BYTES)
    offset = vp_file.tell()
    entries = []

    print_create_header()

    file_list.each do |entry|
      if entry.skip?
        print_create_entry(entry)
      else
        entry.offset = offset

        unless entry.is_dir
          archive_file(entry, vp_file)
          offset += entry.size
        end

        print_create_entry(entry)
        entries << entry
      end
    end

    print_create_footer(entries)

    entries
  end

  def archive_file(entry, vp_file)
    File.open(entry.path, "rb") do |file|
      chunk_size = 1024 * 1024

      until file.eof?
        # read() does not read passed eof even when chunk_size > bytes_remaining
        bytes = file.read(chunk_size)
        vp_write(bytes, vp_file)
      end
    end
  end

  def validate_file_list(file_list)
    entries_size = file_list.sum { |e| e.skip? ? 0 : 1 }

    if entries_size > MAX_ENTRIES
      raise("VP package cannot have more than #{MAX_ENTRIES} files")
    end

    data_size_bytes = file_list.reduce(0) { |acc, e| acc + e.size }
    table_size_bytes = ENTRY_SIZE_BYTES * file_list.size
    total_size = HEADER_SIZE_BYTES + data_size_bytes + table_size_bytes

    if total_size > MAX_VP_SIZE
      raise("VP package cannot be larger than #{MAX_VP_SIZE} bytes")
    end
  end

  def clean_filename(filename)
    max_length = ENTRY_NAME_LENGTH - 1 # minus null terminator

    if filename.length > max_length
      raise("Filename more than #{max_length} characters: #{filename}")
    end

    begin
      filename.encode("ascii")
    rescue
      raise("Filename not ASCII compatible: #{filename}")
    end
  end

  def data_file_list
    get_file_list([], "data", "data")
  end

  def get_file_list(list, name, path)
    if File.directory?(path)
      add_directory_to_list(list, name, path)
    else
      add_file_to_list(list, name, path)
    end
  end

  def add_directory_to_list(list, name, path)
    list << Entry.new(name: name, path: path, is_dir: true)

    Dir.children(path).sort().each do |filename|
      filename = clean_filename(filename)
      file_path = File.join(path, filename)
      list = get_file_list(list, filename, file_path)
    end

    list << Entry.new(name: "..", path: File.join(path, ".."), is_dir: true)
  end

  def add_file_to_list(list, name, path)
    entry = Entry.new(name: name, path: path, is_dir: false)
    entry.size = File.size(path)
    entry.timestamp = File.mtime(path).to_i()
    list << entry
  end

  def print_create_entry(entry)
    return if entry.name == ".."
    action = entry.skip? ? :skip : :archive
    entry_path = to_lower? ? entry.path.downcase() : entry.path
    entry_path = format_path(entry_path, entry.is_dir)

    if verbose?
      entry_data = [strings(action)]
      entry_data << format_size(entry.size, entry.is_dir)
      entry_data << entry.offset if very_verbose?
      entry_data << format_timestamp(entry.timestamp)
      entry_data << entry_path

      fmt_str = very_verbose? ? "%-8s  %10s  %10s  %20s  %s" : "%-8s  %10s  %20s  %s"
    else
      fmt_str = "%8s  %s"
      entry_data = [
        strings(action),
        entry_path,
      ]
    end

    puts(fmt_str % entry_data)
  end

  def print_create_header
    return unless verbose?

    if very_verbose?
      puts(" Action      Size       Offset       Date       Time    Path")
      puts("--------  ----------  ----------  ----------  --------  -----------------------------------")
    else
      puts(" Action      Size        Date       Time    Path")
      puts("--------  ----------  ----------  --------  -----------------------------------")
    end
  end

  def print_create_footer(entries)
    return unless verbose?
    total_size = entries.sum { |e| e.size }
    total_files = entries.sum { |e| (e.skip? || e.name == "..") ? 0 : 1 }
    files_string = total_files == 1 ? "file" : "files"

    if very_verbose?
      puts("--------  ----------  ----------  ----------  --------  -----------------------------------")
      fmt_str = "          %10d                                    %d %s"
    else
      puts("--------  ----------  ----------  --------  -----------------------------------")
      fmt_str = "          %10d                        %d %s"
    end

    puts(fmt_str % [total_size, total_files, files_string])
  end


  ######################################################################
  # FIND DUPLICATES
  ######################################################################

  def find_duplicates
    set_options(command: :find_duplicates)
    vp_paths = Dir.glob("*.vp")

    if vp_paths.size == 0
      puts("No vp files found")
      return
    end

    entries_hash = Hash.new
    vp_paths.each do |vp_path|
      open_vp(vp_path) do |vp_file|
        each_vp_entry(vp_file) do |entry|
          next if entry.is_dir
          entry_path = entry.path.downcase
          entries_hash[entry_path] ||= []
          entries_hash[entry_path] << vp_path
        end
      end
    end

    entries_hash.each do |path, vp_list|
      next unless vp_list.size > 1
      next unless (vp_list - options[:ignore_vps]).size > 0
      printf("%s: %s\n", path, vp_list.join(", "))
    end
  end


  ######################################################################
  # HELPERS
  ######################################################################

  def strings(key)
    case key
    when :skip      then noop? ? "skip"      : "skipped"
    when :overwrite then noop? ? "overwrite" : "overwrote"
    when :create    then noop? ? "create"    : "created"
    when :extract   then noop? ? "extract"   : "extracted"
    when :archive   then noop? ? "archive"   : "archived"
    end
  end

  def mkdir_p(path)
    return if noop?
    return if File.directory?(path)
    FileUtils.mkdir_p(path)
  end

  def vp_write(data, vp_file)
    return 0 if noop?
    vp_file.write(data)
  end

  def stream_entry(entry, vp_file, io)
    vp_file.seek(entry.offset)
    chunk_size = 1024 * 1024
    bytes_remaining = entry.size

    while (bytes_remaining > 0)
      read_size = [chunk_size, bytes_remaining].min()
      bytes = vp_file.read(read_size)
      written_size = io.write(bytes)
      bytes_remaining -= written_size
    end
  end

  def format_timestamp(timestamp)
    timestamp == 0 ? "" : Time.at(timestamp).strftime("%F  %H:%M:%S")
  end

  def format_size(size, is_dir = true)
    return "" if size == 0 && is_dir
    size.to_s()
  end

  def format_path(path, is_dir = false)
    is_dir ? File.join(path, "") : path
  end
end

if $0 == __FILE__
  VP.main()
end
